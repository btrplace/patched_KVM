From bc82d7d9d4c792d74d19bafc8864f769902e9248 Mon Sep 17 00:00:00 2001
From: Vincent KHERBACHE <vincent.kherbache@inria.fr>
Date: Fri, 6 Nov 2015 02:06:58 +0100
Subject: [PATCH] new query-dirty-pages QMP command implementation

---
 migration/ram.c  | 182 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 qapi-schema.json |  14 +++++
 qmp-commands.hx  |  11 ++++
 3 files changed, 207 insertions(+)

diff --git a/migration/ram.c b/migration/ram.c
index df3df9e..deddfe3 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -38,6 +38,8 @@
 #include "trace.h"
 #include "exec/ram_addr.h"
 #include "qemu/rcu_queue.h"
+#include "qemu/thread.h"
+#include "qmp-commands.h"
 
 #ifdef DEBUG_MIGRATION_RAM
 #define DPRINTF(fmt, ...) \
@@ -223,6 +225,7 @@ static QemuMutex migration_bitmap_mutex;
 static uint64_t migration_dirty_pages;
 static uint32_t last_version;
 static bool ram_bulk_stage;
+static QemuDirtyPages qdp;
 
 /* used by the search for pages to send */
 struct PageSearchStatus {
@@ -1688,3 +1691,182 @@ void ram_mig_init(void)
     qemu_mutex_init(&XBZRLE.lock);
     register_savevm_live(NULL, "ram", 0, 4, &savevm_ram_handlers, NULL);
 }
+
+static void *dirty_thread(void *opaque)
+{
+    RAMBlock *block;
+    int64_t ram_bitmap_pages = last_ram_offset() >> TARGET_PAGE_BITS;
+    uint64_t num_dirty_pages_init;
+    static int64_t num_dirty_pages_period;
+    static int64_t start_time;
+    int64_t end_time;
+    int64_t dirty_pages_rate, dirty_bytes_rate;
+    bool first_time = 1;
+    int i = 0;
+
+    // Create the output file
+    FILE *fp = fopen(qdp.file, "wb+");
+
+    // Start dirty logging
+    qemu_mutex_lock_ramlist();
+    qemu_mutex_lock_iothread();
+    memory_global_dirty_log_start();
+    qemu_mutex_unlock_iothread();
+    qemu_mutex_unlock_ramlist();
+
+    // Init an empty bitmap
+    migration_bitmap_rcu = g_new(struct BitmapRcu, 1);
+    migration_bitmap_rcu->bmap = bitmap_new(ram_bitmap_pages);
+    //bitmap_clear(migration_bitmap, 0, ram_pages);
+    bitmap_set(migration_bitmap_rcu->bmap, 0, ram_bitmap_pages);
+    migration_dirty_pages = 0;
+
+    while (1) {
+
+        // Lock iothread + ramlist
+        qemu_mutex_lock_iothread();
+        qemu_mutex_lock_ramlist();
+
+        // Store the last dirty pages count
+        num_dirty_pages_init = migration_dirty_pages;
+
+        // Sync dirty bitmap
+        trace_migration_bitmap_sync_start();
+        address_space_sync_dirty_bitmap(&address_space_memory);
+
+        qemu_mutex_lock(&migration_bitmap_mutex);
+        rcu_read_lock();
+        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {
+            migration_bitmap_sync_range(block->offset, block->used_length);
+        }
+        rcu_read_unlock();
+        qemu_mutex_unlock(&migration_bitmap_mutex);
+
+        trace_migration_bitmap_sync_end(migration_dirty_pages
+                                        - num_dirty_pages_init);
+
+        // Count updated dirty pages
+        num_dirty_pages_period += migration_dirty_pages - num_dirty_pages_init;
+
+        // Get stop time
+        end_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);
+
+        // Ignore the first sync (all pages dirty)
+        if (first_time) {
+            bitmap_set(migration_bitmap_rcu->bmap, 0, ram_bitmap_pages);
+            migration_dirty_pages = 0;
+            num_dirty_pages_period = 0;
+            start_time = end_time;
+            first_time = 0;
+            i = 0;
+        }
+        else {
+            if (qdp.clear) {
+                fprintf(fp, "Round:%d,freq:%" PRIu64 ",pages:%" PRIu64
+                            ",bytes:%" PRIu64 "\n", i, qdp.freq,
+                            migration_dirty_pages, (migration_dirty_pages *
+                            TARGET_PAGE_SIZE));
+                bitmap_set(migration_bitmap_rcu->bmap, 0, ram_bitmap_pages);
+                migration_dirty_pages = 0;
+            }
+            else {
+                fprintf(fp, "Round:%d,total_time:%" PRIu64 ",total_pages:%"
+                            PRIu64 ",total_bytes:%" PRIu64 "\n", i,
+                            (end_time - start_time), num_dirty_pages_period,
+                            (num_dirty_pages_period * TARGET_PAGE_SIZE));
+            }
+        }
+
+        // The delay is reached
+        //if (end_time >= start_time + qdp.delay) {
+        if (i*qdp.freq >= qdp.delay) {
+
+            // Show the rate only if delay > 1s
+            if (qdp.delay >= 1000) {
+                // Compute the dirty rate
+                dirty_pages_rate = num_dirty_pages_period * 1000 /
+                                    (end_time - start_time);
+                dirty_bytes_rate = dirty_pages_rate * TARGET_PAGE_SIZE;
+
+                fprintf(fp, "Rate,pages:%" PRIu64 ",bytes:%" PRIu64 "\n",
+                            dirty_pages_rate, dirty_bytes_rate);
+            }
+            // Unlock ramlist and iothread before exit
+            qemu_mutex_unlock_iothread();
+            qemu_mutex_unlock_ramlist();
+
+            break;
+        }
+
+        // Unlock ramlist and iothread
+        qemu_mutex_unlock_iothread();
+        qemu_mutex_unlock_ramlist();
+
+        // Sleep
+        g_usleep(qdp.freq*1000);
+
+        i++;
+    }
+
+    // Close the output file
+    fclose(fp);
+
+    // Stop dirty logging
+    qemu_mutex_lock_iothread();
+    qemu_mutex_lock_ramlist();
+    memory_global_dirty_log_stop();
+    qemu_mutex_unlock_ramlist();
+    qemu_mutex_unlock_iothread();
+
+    // Freeing bitmap
+    call_rcu(migration_bitmap_rcu, migration_bitmap_free, rcu);
+
+    return NULL;
+}
+
+QemuDirtyPages *qmp_query_dirty_pages(const char* file, int64_t freq,
+                                    bool has_delay, int64_t delay,
+                                    bool has_clear, bool clear, Error **errp)
+{
+    // Init output struct
+    QemuDirtyPages *s;
+    s = g_malloc0(sizeof(*s));
+
+    // Try to create the output file
+    FILE *fp = fopen(file, "wb+");
+    if (fp == NULL) {
+        s->file = strdup("ERROR");
+        return s;
+    }
+    else {
+        fclose(fp);
+        fp = NULL;
+    }
+
+    // Fill the struct with qmp params
+    s->file = strdup(file);
+    s->freq = freq;
+    if (has_delay) {
+        s->delay = delay;
+    }
+    else {
+        s->delay = freq;
+    }
+    if (has_clear) {
+        s->clear = clear;
+    }
+    else {
+        s->clear = 1;
+    }
+
+    // Set the global struct
+    qdp = *s;
+    qdp.file = strdup(file);
+
+    // Launch dirty_thread
+    QemuThread thread;
+    qemu_thread_create(&thread, "dirty_rate", dirty_thread, NULL, QEMU_THREAD_DETACHED);
+
+    return s;
+}
+
diff --git a/qapi-schema.json b/qapi-schema.json
index 702b7b5..83bdf27 100644
--- a/qapi-schema.json
+++ b/qapi-schema.json
@@ -3876,3 +3876,17 @@
 
 # Rocker ethernet network switch
 { 'include': 'qapi/rocker.json' }
+
+##
+# QemuDirtyPages type which contain dirty pages query informations
+##
+{ 'struct': 'QemuDirtyPages',
+  'data': { 'file': 'str', 'freq': 'int', 'delay': 'int', 'clear' : 'bool' } }
+
+##
+# Get dirty pages informations
+##
+{ 'command': 'query-dirty-pages',
+  'data' : { 'file': 'str', 'freq': 'int','*delay': 'int', '*clear': 'bool' },
+  'returns': 'QemuDirtyPages' }
+
diff --git a/qmp-commands.hx b/qmp-commands.hx
index d7cf0ff..1c05dcc 100644
--- a/qmp-commands.hx
+++ b/qmp-commands.hx
@@ -4337,3 +4337,14 @@ Example:
                  {"type": 0, "out-pport": 0, "pport": 0, "vlan-id": 3840,
                   "pop-vlan": 1, "id": 251658240}
    ]}
+
+EQMP
+
+{
+    .name = "query-dirty-pages",
+    .args_type = "file:s,freq:i,delay:i?,clear:b?",
+    .mhandler.cmd_new = qmp_marshal_query_dirty_pages,
+},
+SQMP
+get-dirty-pages
+
-- 
1.8.3.1

